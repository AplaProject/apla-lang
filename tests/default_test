contract myConA {
    arr.map am
    map m1 m2
    m1[`a`] = `a1`
    m1[`b`] = `b1`
    m2[`c`] = `a2`
    m2[`d`] = `b2`
    am += m1
    am += m1
    am += m2
    str out
    for m, i in am {
        if i == 1 {
            continue
        }
        out += str(i)
        for mi, k in m {
            if k == `b` {
                out += `!`
                continue
            }           
            out += mi + ` ` + k  
        }
        out += ` +`
    }
    return out
} 
==== 0a1 a! +2a2 cb2 d +
contract myEq {
    str s = `test 1`
    str out d
    if s == `test 1` {
        out += `1`
    }
    if s != `test 1` {
        out += `x`
    }
    d = s
    if `test2` != s {
        out += `2`
    }
    if d == s {
        out += `3`
    } else {
        out += `y`
    }
    return out
} 
==== 123
contract myCon {
    int sum
    for i in 0..12 {
        if i == 10 {
            continue
        }
        sum += i
    }
    return sum
} 
==== 68
contract myConW {
    int sum i
    while i <=12 {
        if i == 8 {
            i += 2
            continue
        }
        sum += i
        i += 1
    }
    return sum
} 
==== 61
contract myCon {
    int i
    if i == 10 {
        continue
    }
} 
==== myCon 4:9: continue must be inside of while or for
contract myBrw {
    int sum
    int i
    while  i<10 {
        int j
        while j < 20 {
            sum += j
            if j + i == 3 {
                break
            }
            j+=1
        }
        sum += i
        if i == 3 {
            break
        }
        i += 1
    }
    return sum
} 
==== 16
contract myBr {
    int sum
    for i in 0..20 {
        sum += i
        if i == 10 {
            break
        }
    }
    return sum
} 
==== 55
contract myBr {
    int i
    if i == 10 {
        break
    }
} 
==== myBr 4:9: break must be inside of while or for
contract myForCall { 
    int sum
    for i in sum..11-1 {
        sum += i
    }
    return sum
}
==== 55
contract myForCall {
    arr a 
    for i in a..20 {
    }
}
==== myForCall 3:14: Unexpected type arr.str of expression; expecting int
contract myForCall { 
    for i in 0..`10` {
    }
}
==== myForCall 2:17: Unexpected type str of expression; expecting int
contract myKeyserCall { 
    return int(`45ght`)
}
==== cannot convert 45ght to int
contract myformapCall { 
    map.int ai
    int sum k
    ai[`4`] = 10
    ai[`7`] = 20
    for i in ai {       
        sum += i
    }
    ai[`11`] = 3
    for i, j in ai {       
        k += 1
        sum += i + int(j)*k
    }
    return sum
}
==== 103
contract myKeysmapCall { 
    map.int ai
    ai[`z`] = 20
    ai[`a`] = 20
    ai[`тест`] = 20
    ai[`5`] = 10
    str out

    for v, i in Keys(ai) {       
        if i > 0 {
            out += ` `
        }
        out += v
    }
    return out
}
==== 5 a z тест
contract myKeyseCall { 
    map.str ai
    for i, j in ai {
        int k = 1/0
    }
    return Keys(ai)
}
==== []
contract myforCall { 
    arr.int ai
    int sum
    ai += 10
    ai += 20
    for i in ai {       
        sum += i
    }
    ai += 3
    for i, j in ai {       
        sum += i + j
    }
    return sum
}
==== 66
contract myforCall { 
    arr.int ai
    int sum i
    for i in ai {       
    }
}
==== myforCall 5:5: Variable i has already been defined
contract myfCall { 
    for my in 10 {       
    }
}
==== myfCall 2:15: Unexpected type int of expression; expecting array or map
contract myfCall { 
    for my {       
    }
}
==== 2:12: syntax error: unexpected LBRACE, expecting COMMA or IN
contract myfCall { 
    for 10 {       
    }
}
==== 2:9: syntax error: unexpected INT, expecting IDENT
contract myeCall { 
    map bipq
    arr a
    str q = `qqq`
    a += q
    str s = `my`
    bipq[`a`]= `000`
    q += `www`
    s += bipq[`a`]
    s += a[0]
    return s
}
==== my000qqqwww
contract myeqmapCall { 
    map bipq
    str s = `>>`
    bipq[`a`]= `000`
    bipq[`a`] = s
    s += `<<`
    bipq[`b`] = s
    return bipq
}
==== [a: >> b: >><<]
contract myMapCall { 
    map bipq
    str s = `>>`
    bipq[`a`]= `000`
    bipq[`b`]= `111`
    bipq[`c`]= @myMap(bip: bipq, S: s)
    bipq[`d`]= s
    return bipq
}
==== [a: 000 b: 111 c: 6 d: >>]
contract myMap { 
    data {
       map bip
       str S
    }
    if Len(bip) > 0 {
        bip[`aa`] = `checked`
    }
    S += `<<`
    bip[`b`] = `sent`
    return 2*Len(bip)
}
==== 2
contract mapArrtOut { 
    map bip
    str s = `Ooops`
    str a = `x`
    bip[`a`] = s
    bip[`b`] = a
    bip[`a`] = `0`
    s = `1`
    a = s
    return bip[`a`] + bip[`b`] + s + a
}
==== 0x11
contract mapArrArrOut { 
    map.map bip
    map a1 a2
    bip[`a`] = a1
    a1[`b`] = `qqq`
    a2[`c`] = `fff`
    bip[`d`] = a2
    a2[`e`] = `zzz`
    bip[`d`][`e`] = `finish`
    bip[`a`][`b`] = `start`
    a1[`f`]= `ok`
    return bip
}
==== [a: [b: start f: ok] d: [c: fff e: finish]]
contract mapArrISOut { 
    map bip
    str s = `123`
    bip[`a`] = `ppp`
    bip[`b`] = `qqq`
    bip[`a`] = bip[`a`] + `22`
    bip[`b`] = s
    return bip
}
==== [a: ppp22 b: 123]
contract mapArrIndaOutzz { 
    map.int bip
    return bip[`5`]
}
==== Key 5 doesn't exist
contract mapArrIndaOut { 
    map.int bip
    str ind = `Oooops`
    bip[`Oooops`]= 10
    return bip[ind]
}
==== 10
contract assignMapIndex { 
    map.int imap
    imap[`а`] = 1
    imap[`б`]= 2
    imap[`а`] = 3
    imap[`б`] = 4
    return imap
}
==== [а: 3 б: 4]
contract mapArrs { 
    map imap
    str b = `zxcv`
    str a = `asdf`
    imap[`a`] = a
    imap[`b`] = b
    a = `rtyu`
    b = a
    a = `qwer`
    imap[`c`] = b
    return imap
}
==== [a: asdf b: zxcv c: rtyu]
contract mapArrInt { 
    map.int b
    b[`a`] = 3
    b[`b`] = 4
    map.map.int c 
    c[`a`] = b
    c[`b`] = b
    b[`c`] = 5
    return c[`a`][`a`] + 2*c[`a`][`b`] + 3*c[`b`][`a`] + 4*c[`b`][`b`] + c[`a`][`c`] +  c[`b`][`c`]
}
==== 46
contract mapArrStrOut { 
    map.int bip
    bip[`a`] = 7
    return bip[`a`] + bip[`b`]
}
==== Key b doesn't exist
contract mapArrIND { 
    func get() map {
        map b
        b[`0`] = `q`
        b[`1`] = `w`
        return b
    }
    map c = get()
    return c[`1`] + c[`0`] + c[`1`]
}
==== wqw
contract mapArrStrb { 
    map.int bip
    return bip[true]
}
==== mapArrStrb 3:20: Unexpected type bool of expression; expecting str
contract mapArrStrb { 
    map.int b
    return b["my"][1]
}
==== mapArrStrb 3:18: Type int doesn't support indexing
contract mapArrStra { 
    int b
    return b[0]
}
==== mapArrStra 3:15: Type int doesn't support indexing
contract mapArrStra { 
    return a[1]
}
==== mapArrStra 2:15: Variable a hasn't been defined
contract mapArrStrz { 
    map.map.map.map a
}
==== mapArrStrz 2:5: Invalid type
contract mapArrStr { 
    map.map a
    int i
    while i < 3 {
        map b
        int j
        while j < 3 {
            b[str(j)]= str(j+7+i)
            j += 1
        }
        a[str(i)] = b
        i += 1
    }
    return a
}
==== [0: [0: 7 1: 8 2: 9] 1: [0: 8 1: 9 2: 10] 2: [0: 9 1: 10 2: 11]]
contract mapStr1 { 
    map a
    a[`a`] = "17"
    a[`b`]= "AXв"
    a[`c`] = str(Len(a))
    return a
}
==== [a: 17 b: AXв c: 2]
contract mapInt { 
    map.int a
    a[`a`] = 10
    a[`b`]= 123
    a[`a`] = Len(a)
    return a
}
==== [a: 2 b: 123]
contract mapLen { 
    map.int a
    map b
    a[`0`]= 10
    b[`1`]= "my str"
    return Len(a) + Len(b)
}
==== 2
contract mapInt { 
    map.int a
    func dfunc(map e) {}
    dfunc(a)
}
==== mapInt 4:12: Function dfunc(map.int) hasn't been defined
contract mapStr { 
    data {
        map Par
    }
    map a
    map.str d
    func dfunc(map e) {}
    func b(map.str c) str { 
        return "OK"
    }
    b(a)
    dfunc(d)
    return b(Par)
}
==== OK
contract mapCNT { 
    map.map.map.int a
}
==== 
contract mapCNT { 
    map.map.map.map.int a
}
==== mapCNT 2:5: Invalid type
contract myeqCall { 
    arr bipq
    str s = `>>`
    bipq += `000`
    bipq[0] = s
    s += `<<`
    bipq += s
    return bipq
}
==== [>> >><<]
contract myStrCall { 
    str s = `>>`
    str a = s
    s += `===`
    return a + s
}
==== >>>>===
contract myArrCall { 
    arr bipq
    str s = `>>`
    bipq += `000`
    bipq += `111`
    bipq += @myArr(bip: bipq, S: s)
    bipq += s
    return bipq
}
==== [000 111 6 >>]
contract myArr { 
    data {
       arr bip
       str S
    }
    if Len(bip) > 0 {
        bip[0] = `checked`
    }
    S += `<<`
    bip += `sent`
    return 2*Len(bip)
}
==== 2
contract arrArrtOut { 
    arr bip
    str s = `Ooops`
    str a = `x`
    bip += s
    bip += a
    bip[0] = `0`
    s = `1`
    a = s
    return bip[0] + bip[1] + s + a
}
==== 0x11
contract arrArrArrOut { 
    arr.arr bip
    arr a1 a2
    bip += a1
    a1 += `qqq`
    a2 += `fff`
    bip += a2
    a2 += `zzz`
    bip[1][1] = `finish`
    bip[0][0] = `start`
    a1 += `ok`
    return bip
}
==== [[start ok] [fff finish]]
contract arrArrISOut { 
    arr bip
    str s = `123`
    bip += `ppp`
    bip += `qqq`
    bip[0] = bip[0] + `22`
    bip[1] = s
    return bip
}
==== [ppp22 123]
contract arrArrIndaOutes { 
    arr.int bip
    bip[-3] = 2
}
==== index out of range index:-3 len:0
contract arrArrIndaOutzz { 
    arr.int bip
    return bip[-5]
}
==== index out of range index:-5 len:0
contract arrArrIndaOut { 
    arr.int bip
    int ind = 0
    bip += 10
    return bip[ind]
}
==== 10
contract arrArrIndOut { 
    arr.int bip
    bip += 1
    bip[10] = 2
}
==== index out of range index:10 len:1
contract assignIndex { 
    arr.int iarr
    iarr += 1
    iarr += 2
    iarr[0] = 3
    iarr[1] = 4
    return iarr
}
==== [3 4]
contract arrArrs { 
    arr iarr
    str b = `zxcv`
    str a = `asdf`
    iarr += a
    iarr += b
    a = `rtyu`
    b = a
    a = `qwer`
    iarr += b
    return iarr
}
==== [asdf zxcv rtyu]
contract arrArrInt { 
    arr.int b
    b += 3
    b += 4
    arr.arr.int c 
    c += b
    c += b
    b += 5
    return c[0][0] + 2*c[0][1] + 3*c[1][0] + 4*c[1][1] + c[0][2] +  c[1][2]
}
==== 46
contract arrArrStrOut { 
    arr.int bip
    bip += 1
    return bip[0] + bip[1]
}
==== index out of range index:1 len:1
contract arrArrIND { 
    func get() arr {
        arr b
        b += `q`
        b += `w`
        return b
    }
    arr c = get()
    return c[1] + c[0] + c[1]
}
==== wqw
contract arrArrStrb { 
    arr.int bip
    return bip[true]
}
==== arrArrStrb 3:20: Unexpected type bool of expression; expecting int
contract arrArrStrb { 
    arr.int b
    return b[0][1]
}
==== arrArrStrb 3:15: Type int doesn't support indexing
contract arrArrStra { 
    int b
    return b[0]
}
==== arrArrStra 3:15: Type int doesn't support indexing
contract arrArrStra { 
    return a[1]
}
==== arrArrStra 2:15: Variable a hasn't been defined
contract arrArrStrz { 
    arr.arr.arr.arr a
}
==== arrArrStrz 2:5: Invalid type
contract arrArrStr { 
    arr.arr a
    int i
    while i < 3 {
        arr b
        int j
        while j < 3 {
            b += str(j+7+i)
            j += 1
        }
        a += b
        i += 1
    }
    return a
}
==== [[7 8 9] [8 9 10] [9 10 11]]
contract arrStr1 { 
    arr a
    a += "17"
    a += "AXв"
    a += str(Len(a))
    return a
}
==== [17 AXв 2]
contract arrInt { 
    arr.int a
    a += 10
    a += 123
    a += Len(a)
    return a
}
==== [10 123 2]
contract arrLen { 
    arr.int a
    arr b
    a += 10
    b += "my str"
    return Len(a) + Len(b)
}
==== 2
contract arrInt { 
    arr.int a
    func dfunc(arr e) {}
    dfunc(a)
}
==== arrInt 4:12: Function dfunc(arr.int) hasn't been defined
contract arrStr { 
    data {
        arr Par
    }
    arr a
    arr.str d
    func dfunc(arr e) {}
    func b(arr.str c) str { 
        return "OK"
    }
    b(a)
    dfunc(d)
    return b(Par)
}
==== OK
contract arrCNT { 
    arr.arr.arr.int a
}
==== 
contract arrCNT { 
    arr.arr.arr.arr.int a
}
==== arrCNT 2:5: Invalid type
contract arrInt { 
    func a() int.int {
    }
}
==== arrInt 2:14: Invalid type
contract arrInt { 
    func a(int.int b) {
    }
}
==== arrInt 2:12: Invalid type
contract arrInt { 
    data {
        int.int b
    }
}
==== arrInt 3:9: Invalid type
contract arrInt { 
    int.int b
}
==== arrInt 2:5: Invalid type
contract callName { 
    str s = `ok`
    return @myData(Name: "Only Name") + s + @myData(Value: 17)
}
==== Only Name 0okEmpty name 9
contract callData { 
    return @myData(Name: "My Data", Value: 50)
}
==== My Data 50
contract callData { 
    return @myData(Name: "My Data", Value: "string")
}
==== callData 2:52: Unexpected type of the parameter; expecting int
contract callData { 
    return @myData(Name: "My Data", Value2: 50)
}
==== callData 2:47: Contract doesn't have Value2 parameter
contract callData { 
    return @myDIV(Name: "My Data", Value: 50)
}
==== callData 2:45: Contract myDIV doesn't have parameters
contract myData { 
    data { 
        int Value
        str Name 
    }
    str s = ` `
    if Len(Name) == 0 {
        Name = `Empty name`
        Value = 9
    }
    return Name + s + str(Value)
}
==== Empty name 9
contract myCallDIV {
    @myDIV()
}
==== integer divide by zero
contract myCall {
    return @mySLem() + @mySLem()
}
==== 123456123456
contract myCall {
    @mySLem2()
}
==== myCall 2:14: Contract mySLem2 hasn't been found
contract mySVar {
    str a
    str s = "start" + a
    s += ` `
    a = `!`
    return s + s + a
}
==== start start !
contract myLem {
    return Len(`stri\ning` + "start\nТест" + "first
second")
}
==== 36
contract mySLem {
    return `123` + "456"
}
==== 123456
contract mystr3 {
    return `stri\g т\""ест 123 + - /?`
}
==== stri\g т\""ест 123 + - /?
contract mystr2 {
    return "string \t \" \\\" 123 456"
}
==== string 	 " \" 123 456
contract mystr1 {
    return "string \t \" \\\""
}
==== string 	 " \"
contract mystr {
    return "st\king"
}
==== 2:12: invalid syntax
contract myFunc1 {
    func name(int a) int {
        int b = 10
        int c  = 3
        if a == 2 {
            return (b+c)*3
        }
        return (b + c + a)
    }
    return  name(3) + 2*name(2) 
}
==== 94
contract myparFunc {
    func name_int(int a) int {
        return a + 10
    }
    return name_int(true)
}
==== myparFunc 5:25: Function name_int(bool) hasn't been defined
contract myparFunc {
    int c
    func name_int(int a b) int {
        c+=1
        return (b-a + 1)*c
    }
    return name_int(3,4) + name_int(1,4)
}
==== 10
contract myEmpaFunc {
    func name() int {
        return true
    }
}
==== myEmpaFunc 3:21: Function must return int
contract myEmpaFunc {
    func name() int {
        return 
    }
}
==== myEmpaFunc 3:17: Function must return a value
contract myEmpaFunc {
    int a
    func name() {
        return a
    }
}
==== myEmpaFunc 4:18: Function cannot return a value
contract myEmpFunc {
    int a
    func name() {
        a += 3
        return
    }
    name()
    return a 
}
==== 3
contract myAFunc {
    int a
    func name() int {
        a += 1
    }
}
==== myAFunc 5:5: Function must return a value
contract myAFunc {
    int a
    func name() int {
        a += 1
        return  a * 2
    }
    return name() + name() * name()
}
==== 26
contract myAFunc {
    func main() int {
        func sub() {
        }
    }
}
==== myAFunc 4:9: Function cannot be defined inside another function
contract myFunc {
    if true {
        int a
        func name() {
            a += 1
            a *= 2
        }
        name()
        name()
        return a
    }
}
==== 6
contract myFunc {
    name()
}
==== myFunc 2:10: Function name() hasn't been defined
contract myFunc {
    func name() {
    }
    func name() {
    }
}
==== myFunc 5:5: Function name has already been defined
contract myQuest {
    int i
    i += 1 + ?(i==0, 7+2, 2/0)
    i += 2 + ?(i<0, 2/0, 3)
    return i
}
==== 15
contract myQuest {
    return ?(true, 7+2, false)
}
==== myQuest 2:30: Different types of ?
contract myCycle {
    int i
    while i < 1000 {
        int j k
        j = i 
        k = i*2
        if k > i {
            int x = j
            j = x + 2
        }
        i += 1
    }
    return i
}
==== 1000
contract myORAND {
    bool b = 10 > 1 || 2/0 == 3
    if !b {
        return false
    }
    b = b && 1 > 5 && 6/0 == 7
    b = !b && true && 5==5
    return b
}
==== true
contract myIf {
    int ret = 1
    if ret == 1 {
        ret += 2
    }
    if ret < 3 {
        ret /= 2
    } else {
        ret += 5
    }
    if false {
        ret *=3
    } elif ret < 10 {
        ret *= 2
    }
    if ret < 10 {
        ret *=3
    } elif ret != 16 {
        ret *= 2
    } elif ret == 16 {
        ret += 4
    } elif ret >5 {
        ret/=3
    } elif ret == 5 {
        ret -= 20
    } else {
        ret *= 0
    }
    if ret < 10 {
        ret *=3
    } elif ret == 16 {
        ret *= 2
    } elif false {
        ret += 4
    } else {
        ret *= 2
    }
    return ret
} 
==== 40
contract myIf {
    int ret
    if true  {
    } elif ret {
    }
} 
==== myIf 4:12: Unexpected type int of expression; expecting bool
contract myIf {
    int ret
    if ret  {
    }
} 
==== myIf 3:8: Unexpected type int of expression; expecting bool
contract myFact {
    int f = 1
    int i = 1
    while i <= 16 {
        f *= i
        i+=1
    }
    return f
} 
==== 20922789888000
contract myWhile {
    int i sum
    while i < 5 {
        int j
        while j <= i {
            sum += j
            j+=2
        }
        i+=1
    }
    return sum
} 
==== 10
contract myVar {
    int myVar
    while false {
        int myVar
    }
} 
==== myVar 4:19: Variable myVar has already been defined
contract myGT {
    while 10 + 5 {
    }
} 
==== myGT 2:18: Unexpected type int of expression; expecting bool
contract myGT {
    while 10 {
    }
} 
==== myGT 2:11: Unexpected type int of expression; expecting bool
contract myGT {
    return 5 > 10
} 
==== false
contract myGE {
    return 6 >= 6
} 
==== true
contract myLT {
    return 5 < 10
} 
==== true
contract myLE {
    return 6 >= 6
} 
==== true
contract myNE2 {
    return 5 != 10
} 
==== true
contract myNE1 {
    return 8+2 != 10
} 
==== false
contract myEQ2 {
    return 5 == 10
} 
==== false
contract myEQ1 {
    int a = 10
    return a == 10
} 
==== true
contract myVarSetAB {
    int a
    a += true
} 
==== myVarSetAB 3:15: Operator int+=bool has not been found
contract myMod2 {
    int a = 21 % 0
} 
==== integer divide by zero
contract myMod {
    int a = 21
    a %= 2-2
} 
==== integer divide by zero
contract myVarAssign {
    int a = 7
    int b = a + 3
    a += 8
    b -= 5
    a *= b + 5
    b /=5
    a %= 17
    return a + b
} 
==== 15
contract myVarSetAB {
    int a = 10
    int b = 15
    b = b + 1
    return a + b + a % 3
} 
==== 27
contract myVarSet {
    int a
    a = 23
    return (a - 3)/4 + a
} 
==== 28
contract myVar {
    int a
    {
        return 20
    }
    return a
} 
==== 3:5: syntax error: unexpected LBRACE, expecting RBRACE
contract myVar {
    int a
    return (a + 3)*2
} 
==== 6
contract myNoVar {
    return 1 + b
} 
==== myNoVar 2:16: Variable b hasn't been defined
contract myVarE1 {
    int abc 
    int abc
} 
==== myVarE1 3:13: Variable abc has already been defined
contract myVarE {
    int abc abc
} 
==== myVarE 2:17: Variable abc has already been defined
contract myDIV {
    return 100/(15-0xf)
} 
==== integer divide by zero
contract myMULF {
    return 2*false
} 
==== myMULF 2:14: Operator int*bool has not been found
contract myMUL {
    return 0xFF - 2*(50-16) + (20+52)/3 + (20-5 + 7)*3/0x2 + 8/3
} 
==== 246
contract myAdd {
    return 0xFF + 1 + -100 - 56 - -1000
} 
==== 1100
contract myPush64 {
    return 0xFFFFFFFFFF
} 
==== 1099511627775
contract myPushn64 {
    return 0x10AbFc32
} 
==== 279706674
contract myPushn3212 {
    return -2147483648
} 
==== -2147483648
contract myPushn321 {
    return -1
} 
==== -1
contract myPushn32 {
    return 2147483647
} 
==== 2147483647
contract myPush32 {
    return (1000123)
} 
==== 1000123
contract myNOTTR {
    return !true
} 
==== false
contract myTR {
    return true
} 
==== true
contract myE {
    return -true
} 
==== myE 2:13: Operator -bool has not been found
contract myS {
    return -100
} 
==== -100
contract my777 {
    return 777
} 
==== 777
contract Empty {
    return
} 
==== 
contract my {
    return
} 
==== Contract my has already been defined
contract my {
    10
} 
==== 2:5: syntax error: unexpected INT, expecting RBRACE
contract my {
} 
==== 
contract my {
} 
contract myNext {
} 
==== 3:1: syntax error: unexpected CONTRACT, expecting NEWLINE
myvar contract {
} 
==== 1:1: syntax error: unexpected IDENT, expecting CONTRACT
contract {
} 
==== 1:10: syntax error: unexpected LBRACE, expecting IDENT
/* 
   ==== expecting result or error text
   ==== gas $ expecting result or error text
*/
==== 4:3: syntax error: unexpected $end, expecting CONTRACT

